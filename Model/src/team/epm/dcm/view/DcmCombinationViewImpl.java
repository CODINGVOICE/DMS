package team.epm.dcm.view;

import java.sql.PreparedStatement;
import java.sql.ResultSet;

import java.sql.SQLException;

import java.util.List;

import oracle.jbo.RowIterator;
import oracle.jbo.server.ViewObjectImpl;
import oracle.jbo.server.ViewRowImpl;
import oracle.jbo.server.ViewRowSetImpl;

import team.epm.dcm.model.DcmCombinationImpl;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Mon Nov 17 15:31:33 CST 2014
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class DcmCombinationViewImpl extends ViewObjectImpl {
    /**
     * This is the default constructor (do not remove).
     */
    public DcmCombinationViewImpl() {
    }


    public void createTable(String code,List<String> columns) throws SQLException {
        StringBuffer sqlbuf=new StringBuffer();
        sqlbuf.append("CREATE TABLE ");
        sqlbuf.append(code);
        sqlbuf.append("(ID VARCHAR2(32) , ");
        int i;
        for(i=0;i<columns.size();i++){
            String c=columns.get(i);
            sqlbuf.append(c);
            sqlbuf.append(" VARCHAR2(100),");
        }
        sqlbuf.append(" CONSTRAINT PK_"+code+" PRIMARY KEY(ID))");
        String sqlstr=sqlbuf.toString();
        PreparedStatement pst =this.getDBTransaction().createPreparedStatement(sqlstr, 0);
        try {
            pst.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
            throw e;
        }
        this.getDBTransaction().commit();
    }
    public void refreshCombinationRecord(String combiantonCode,List<String> vsTables,List<String> valueSetCodes) throws SQLException {
        StringBuffer sql=new StringBuffer();
        StringBuffer sql_from=new StringBuffer();
        StringBuffer sql_sub=new StringBuffer();
        sql.append("INSERT INTO \"").append(combiantonCode).append("\"");
        sql.append(" SELECT DCM_SEQ.NEXTVAL ");
        sql_from.append(" FROM ");
        sql_sub.append("SELECT 1 FROM \"").append(combiantonCode).append("\" T WHERE 1=1");
        for(int i=0;i<valueSetCodes.size();i++){
            sql.append(",T").append(i).append(".CODE");
            sql_from.append("\"").append(vsTables.get(i)).append("\"").append(" T").append(i).append(",");
            sql_sub.append(" AND T.\"").append(valueSetCodes.get(i)).append("\"");
            sql_sub.append("=").append("T").append(i).append(".CODE");
        }
        int n=sql_from.lastIndexOf(",");
        sql_from.deleteCharAt(n);
        sql.append(sql_from);
        sql.append(" WHERE NOT EXISTS(");
        sql.append(sql_sub).append(")");
        this.getDBTransaction().createStatement(0).execute(sql.toString());
        this.getDBTransaction().commit();
    }

    /**
     * Returns the bind variable value for locale.
     * @return bind variable value for locale
     */
    public String getlocale() {
        return (String)getNamedWhereClauseParam("locale");
    }

    /**
     * Sets <code>value</code> for bind variable locale.
     * @param value value to bind as locale
     */
    public void setlocale(String value) {
        setNamedWhereClauseParam("locale", value);
    }
}
